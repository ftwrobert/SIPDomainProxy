#!KAMAILIO -- config for SIPDomainProxy
################################################################################
# Title:  SIPDomainProxy
# Author: Robert J. Ebel
################################################################################



################################################################################
# Routing Blocks (authentication)
################################################################################

route[AUTHENTICATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: AUTHENTICATION\n");
#!endif

  if (is_method("INVITE|REFER")) {
    # Accept any PBX -> Subscriber.
    if (src_ip == "PRIVSUBNET/PRIVMASK") {
      xlog("L_NOTICE", "LAN PBX Authenticated based on $si\n");
      return;
    }

    route(SET_PAI);

    # Subscriber -> PBX, run through authentication process.
    switch($avp(dattr_authtype)) {
      case "passthrough":
        return;
      case "registration":
        route(KAMAILIO_AUTHENTICATION);
        return;
      default:
        xlog("L_NOTICE", "Domain attribute failure (authtype)\n");
        sl_send_reply("500", "Internal Server Error");
        exit;
    }
  }
}

route[KAMAILIO_AUTHENTICATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: KAMAILIO_AUTHENTICATION\n");
#!endif
  # attempt IP Auth first
  if (allow_trusted()) {
    # src_ip is in the trusted table, BUT, we need to do additional validation.
    xlog("L_NOTICE", "$si is trusted.\n");
    route(TRUSTED_AUTHENTICATION);
  }
  else {
    route(DIGEST_AUTHENTICATION);
  }
  return;
}

route[TRUSTED_AUTHENTICATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: TRUSTED_AUTHENTICATION\n");
#!endif
  sql_xquery("ca",
             "SELECT COUNT(customer_auth.id) "
             "FROM customer_auth "
             "LEFT JOIN trusted "
             "ON customer_auth.trusted_id=trusted.id "
             "LEFT JOIN customer_auth.domain_id=domain.id "
             "WHERE trusted.src_ip = '$si' "
             "AND domain.domain = '$td' ",
             "ra");
  if ($dbr(ra=>rows) < 1) {
    # No results, not authenticated.
    # We'll pass this back and look for digest auth
    xlog("L_NOTICE", "$si is not authorized for domain $td\n");
    sql_result_free("ra");
    route(DIGEST_AUTHENTICATION);
    return;
  }
  else {
    xlog("L_NOTICE", "$si is authorized for domain $td\n");
    return;
  }

  # If we're still here, something went wrong :/
  sl_send_reply("500", "Internal Server Error");
  exit;
}

route[DIGEST_AUTHENTICATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: DIGEST_AUTHENTICATION\n");
#!endif
  # Stateful mode required for nonce protection
  t_lookup_request();

  if(!proxy_authenticate("$fd", "subscriber")) {
    route(AUTH_DB_RETCODE);
    proxy_challenge("$td", "1");
    t_release();
    exit;
  }
  else {
    # Digest Authentication has succeeded
    xlog("L_NOTICE", "Digest Authentication successfull from $si\n");
    consume_credentials();
    return;
  }

  # If we're still here, something went wrong :/
  sl_send_reply("500", "Internal Server Error");
  exit;
}
