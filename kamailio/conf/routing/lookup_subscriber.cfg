#!KAMAILIO -- config for SIPDomainProxy
################################################################################
# Title:  SIPDomainProxy
# Author: Robert J. Ebel
################################################################################



################################################################################
# Routing Blocks (lookupsubscriber)
################################################################################

route[LOOKUP_SUBSCRIBER] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "route: ROUTING\n");
#!endif
  # Requests from PBX -> UAC
  if (src_ip == "PRIVSUBNET/PRIVMASK") {
    # !FIXME! Look up DID and find subscriber list
    # look up the UAC binding
    # Determine if this proxy is responsible for registration. If so, we'll need
    # to map DID's to a registration, otherwise, we pass through.

    switch($avp(dattr_authtype)) {
      case "passthrough":
        # nothing complicated, verify we know about the end point before relay
        if (!lookup("location")) {
            xlog("L_NOTICE", "Passthrough contact is not registered\n");
            sl_send_reply("404", "Not Found");
            exit;
        }
        xlog("L_NOTICE", "Passthrough contact has been resolved, $ru\n");
        return;
      case "registration":
        route(LOOKUP_SUBSCRIBER_REGISTRATION);
        return;
      default:
        xlog("L_NOTICE", "Domain attribute failure (authtype)\n");
        sl_send_reply("500", "Internal Server Error");
        exit;
    }
    if (subst('/Contact: <sip:(.*)@(.*)$/Contact: <sip:\1@$fd\r/ig')) {
      xlog("L_NOTICE", "Updated Contact, set domain to $fd\n");
    }
    return;
  }
  # Requests from UAC -> PBX
  else {
    # Update the request domain and port to relay to the PBX
    $rd = $(avp(dattr_pbx_addr));
    $rp = $(avp(dattr_pbx_sipport));

    # !FIXME! setting the contact's domain to $fd may mean the PBX routes to
    # it's default gateway and that routes back to this proxy via hairpin nat
    # If so, this IS NOT desirable -- would we be able to get away with setting
    # the domain to PRIVADDR?
    # If we "can", we may then need to update the domain before looking up the
    # subscribers location.
    if (subst('/Contact: <sip:(.*)@(.*)$/Contact: <sip:\1@$fd\r/ig')) {
      xlog("L_NOTICE", "Updated Contact, set domain to $fd:$rp\n");
    }
    return;
  }
  # If we're still here, something went wrong :/
  sl_send_reply("500", "Internal Server Error");
  exit;
}

route[LOOKUP_SUBSCRIBER_REGISTRATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "route: LOOKUP_SUBSCRIBER_REGISTRATION\n");
#!endif
  # "Look up DID"
  # Save the Request User, We want to
  # restore it when we are done finding the subscriber.
  $var(orig_ru) = $rU;
  $var(orig_rd) = $rd;

  # This query finds all billing group authentications and sorts them by
  # priority.
  # Within the same priority, digest authentications take priority over trusted
  # addresses.
  # Each of the authentication types are sorted by their index, meaning older
  # records are priortized over newer records
  sql_xquery("ca",
    "SELECT customer_auth.priority, "
    "       customer_auth.id, "
    "       subscriber.username, "
    "       trusted.src_ip, "
    "       CASE WHEN subscriber.username IS NULL "
    "         THEN 'trusted' "
    "         ELSE 'digest' "
    "       END as type "
    "FROM did_numbers "
    "LEFT JOIN customer_bg ON did_numbers.customer_bg_id=customer_bg.id "
    "LEFT JOIN customer_auth ON customer_bg.id=customer_auth.customer_bg_id "
    "LEFT JOIN subscriber ON customer_auth.subscriber_id=subscriber.id "
    "LEFT JOIN trusted ON customer_auth.trusted_id=trusted.id "
    "WHERE did_numbers.id IN (SELECT id "
    "                         FROM did_numbers "
    "                         WHERE prefix @> '$rU' "
    "                         ORDER BY LENGTH(prefix) DESC "
    "                         LIMIT 1) "
    "AND customer_auth.domain_id IN (SELECT id "
    "                                FROM domain "
    "                                WHERE domain = '$rd' "
    "                                LIMIT 1) "
    "ORDER BY customer_auth.priority, "
    "         CASE WHEN subscriber.username IS NULL "
    "           THEN 1 "
    "           ELSE 0 "
    "         END, "
    "         customer_auth.id"
  ,"auths");

  if ($dbr(auths=>rows) < 1) {
    xlog("L_NOTICE", "No authentications found for $rU@$rd\n");
    sl_send_reply("404", "Not Found");
    sql_result_free("auths");
    exit;
  }

  # Print out the routes that we have found
#!ifdef TESTBED_MODE
  $var(i) = 0;
  while ($var(i) < $dbr(auths=>rows)) {
    xlog("L_NOTICE", "$dbr(auths=>[$var(i),4]) Auth "
                     "Q: $dbr(auths=>[$var(i),0]/$dbr(auths=>[$var(i),1]) "
                     "Subscriber: $dbr(auths=>[$var(i),2]) "
                     "Trusted Addr: $dbr(auths=>[$var(i),3])\n");
    $var(i) = $var(i) + 1;
  }
#!endif

  $var(i) = $dbr(auths=>rows) - 1;
  while ($var(i) >= 0) {
    switch($dbr(auths=>[$var(i),4])) {
      case "digest":
        $(avp(s:auths)[$var($i)]) = "digest;" + $dbr(auths=>[$var(i),2]);
      case "trusted"
        $(avp(s:auths)[$var($i)]) = "trusted;" + $dbr(auths=>[$var(i),3]);
    }
    $var(i) = $var(i) - 1;
  }
  sql_result_free("auths");

  $avp(s:auths_idx) = 0;

  route(ATTEMPT_AUTH_SUBSCRIBER);
}

route[ATTEMPT_AUTH_SUBSCRIBER] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "route: ATTEMPT_AUTH_SUBSCRIBER\n");
#!endif
  t_on_failure("ADVANCE_AUTH_SUBSCRIBER");

  $var(auth_str) = $(avp(s:auths)[$avp(s:auths_idx)]);
  $var(auth_type) = $(var(auth_str){s.select,0,;});
  $var(auth_param) = $(var(auth_str){s.select,1,;});
  $rd = $var(orig_rd);

  switch($var(auth_type)) {
    case "trusted":
      $rd = $var(auth_param); # param is the trusted addr of the subscriber when
                              # auth_type = "trusted"
      break;
    case "digest":
      $rU = $var(auth_param); # param is the subscribers username when
                              # auth_type = "digest"
      if (!lookup("location")) {
        xlog("Contact not found\n");
        route(ADVANCE_AUTH_SUBSCRIBER);
        break;
      }
      $rU = $var(orig_ru);
      break;
    default:
      t_reply("500", "Internal Server Error");
      xlog("L_err", "Unknown auth type\n");
      exit;
  }
}

route[ADVANCE_AUTH_SUBSCRIBER] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "route: ADVANCE_AUTH_SUBSCRIBER\n");
#!endif
  xlog("L_NOTICE", "Attempting to advance route\n");

  $avp(s:auths_idx) = $avp(s:auths_idx) + 1;

  if (!is_avp_set("$(avp(s:auths)[$avp(s:auths_idx)])")) {
    t_reply("486", "Busy Here");
    xlog("L_NOTICE", "No more routes, the call has failed\n");
    exit;
  }

  t_on_failure("ADVANCE_AUTH_SUBSCRIBER");

  route(ATTEMPT_AUTH_SUBSCRIBER);

}
