#!KAMAILIO -- config for SIPDomainProxy
################################################################################
# Title:  SIPDomainProxy
# Author: Robert J. Ebel
# Date:   20190410
################################################################################



################################################################################
# Routing Blocks (authentication)
################################################################################

route[REGISTRATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: REGISTRATION"\n);
#!endif
  if (method=="REGISTER") {
    switch($avp(dattr_authtype)) {
      case "passthrough":
        route(PASSTHROUGH_REGISTRATION);
        exit;
      case "kamailio":
        route(KAMAILIO_REGISTRATION);
        return;
      default:
        xlog("L_NOTICE", "Domain attribute failure (authtype).\n");
        sl_send_reply("500", "Internal Server Error");
        exit;
    }
  }
}

route[PASSTHROUGH_REGISTRATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: PASSTHROUGH_REGISTRATION"\n);
#!endif
  # Save the location but do not reply. We'll pass this to the PBX.
  if (!save("location", "0x06")) {
    sl_reply_error();
  }

  # Update the request domain and port to relay to the PBX
  $rd = $(avp(dattr_pbx_addr));
  $rp = $(avp(dattr_pbx_sipport));

  # Add a Path header so we can route replies back to the UAC
  add_path_received($fU);

  # !FIXME! We may need to re-write the Contact header here.
  if (subst('/Contact: <sip:(.*)@(.*)$/Contact: <sip:\1@$fd\r/ig')) {
    xlog("L_NOTICE", "Updated Contact, set domain to $fd.\n");
  }

  route(RELAY);
  exit;
}

route[KAMAILIO_REGISTRATION] {
#!ifdef TESTBED_MODE
xlog("L_DBG", "[$ci] branch_route: KAMAILIO_REGISTRATION"\n);
#!endif
  # Statefull mode required for nonce protection
  t_lookup_request();

  if (!www_authenticate("$td", "subscriber")) {
    switch ($retcode) {
      case -1:
        xlog("L_NOTICE", "Bad Credentials or generic error.\n");
        break;
      case -2:
        xlog("L_NOTICE", "Bad Credentials (invalid password).\n");
        send_reply("403" "Forbidden");
      case -3:
        xlog("L_NOTICE", "Bad Credentials (invalid user).\n");
        send_reply("403" "Forbidden");
      default:
        xlog("L_NOTICE", "Authentication error, sending challenge.\n");
    }
    www_challenge("$td", "1");
    t_release();
    exit;
  }
  # Credentials verified.
  xlog("L_NOTICE", "Authentication Credentials verified.\n");

  if (search_hf("Contact", ";expires=0", "f")) {
    xlog("L_NOTICE", "$tu requested immediate expiration of registration.\n");
  }

  # Do not pass credentials to upstream domain
  consume_credentials();

  # This flag is used for NAT Keep-Alive
  setbflag("7");

  if (!save("location")) {
    xlog("L_NOTICE", "Failed to save binding\n");
    send_reply("503", "Service Unavailable");
    exit;
  }

  xlog("L_NOTICE", "Registration binding ($ct) saved for $tU@$td\n");

  # !FIXME! Do we need to manually send back a 200 OK? Does consume_credentials
  #   take care of that for us?
  # If so, do we need to exit execution here?

}
